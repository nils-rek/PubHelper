.libPaths("C:/Users/nkapp/R")
getwd()
document()
library("roxygen2")
document()
library("devtools")
document()
document()
library("roxygen2")
library("devtools")
.libPaths("C:/Users/nkapp/R")
library("roxygen2")
document()
getwd()
library("devtools")
document()
data("airquality")
airquality$Period = ifelse(airquality$Month %in% 5:7, "Early Summer", "Late Summer")
head(airquality)
?airquality
baselineTable(data = airquality, vars = c("Ozone", "Solar.R", "Wind", "Temp", "Period"),
labels = c("Ozone (ppb)", "Solar R (lang)", "Wind (mph)", "Temperature (degrees F)", "Period"))
baselineTable(data = airquality, vars = c("Ozone", "Solar.R", "Wind", "Temp"),
labels = c("Ozone (ppb)", "Solar R (lang)", "Wind (mph)", "Temperature (degrees F)"),
grouping.var = "Period", round_dec = 1)
?t.test
welch.test = TRUE
welch.test
!welch.test
welch.test = FALSE
!welch.test
placeholder
placeholder = "   "
placeholder
paste0(placeholder, c("Mean (SD)",
"Median (IQR)"))
paste0(placeholder, "Median (IQR)")
library("devtools")
document()
SDfromCI <- function(n = NA, ci.lb = NA, ci.ub = NA)  {
# Check input arguments
if(sum(is.na(c(n, ci.lb, ci.ub))) >= 1)  {
stop("Please define all input arguments for computation of the pooled mean")
}
# Formula for SD inference
sd <- sqrt(n) * (ci.ub - ci.lb) / 3.92
# Return output
return(sd)
}
SDfromCI(n = 30, ci.lb = -0.1, ci.ub = 0.2)
sdpooled <- function(n1 = NA, n2 = NA, sd1 = NA, sd2 = NA)  {
# Check input arguments
if(sum(is.na(c(n1, n2, sd1, sd2))) >= 1)  {
stop("Please define all input arguments for computation of the pooled standard deviation")
}
# Pooled SD formula
sd_pooled <- sqrt(((n1 - 1) * sd1^2 + (n2 - 1) * sd2^2) / (n1 + n2 - 2))
# Return output
return(sd_pooled)
}
sdpooled(n1 = 30, n2 = 20, sd1 = 15, sd2 = 20)
meanpooled <- function(n1 = NA, n2 = NA, mean1 = NA, mean2 = NA)  {
# Check input arguments
if(sum(is.na(c(n1, n2, mean1, mean2))) >= 1)  {
stop("Please define all input arguments for computation of the pooled mean")
}
# Pooled Mean formula
mean_pooled <- (n1 * mean1 + n2 * mean2) / (n1 + n2)
# Return output
return(mean_pooled)
}
meanpooled(n1 = 30, n2 = 20, mean1 = 15, mean2 = 20)
devtools::document()
library("devtools")
.libPaths("C:/Users/nkapp/R")
library("devtools")
document()
data(airquality)
head(airquality)
airquality[1,] = NULL
airquality[-1,] = NULL
data = airquality
head(airquality)
summary(airquality)
vars = c("Ozone", "Solar.R", "Wind", "Temp")
labels = NULL
grouping.var = NULL
round_dec = 2
placeholder = "   "
welch.test = FALSE;
na.statistics = "all";
print.vars = FALSE
airquality$Period = ifelse(airquality$Month %in% 5:7, "Early Summer", "Late Summer")
addGroupInfoToTable <- function(
data,
output,
vars,
placeholder,
round_dec,
grouping.var,
welch.test
)   {
## Get levels of new variable
group.levels = unique(data[, grouping.var])
group.levels = group.levels[!is.na(group.levels)]
## Create additional columns
output[, c(group.levels, "test")] = NA
## Fill new columns in loop
for(i in vars) {
# Save output.type
output.type = output[output$vars == i, "output.type"][1]
## Run tests and fill test column depending on output.type
if(output.type == "cont")   {
# T-test if 2 levels and ANOVA if more levels
if(length(group.levels) == 2) {
# Run t-test
t.test_results = t.test(data[, i] ~ data[, grouping.var], var.equal = !welch.test)
t.test_p = ifelse(t.test_results$p.value < 0.001, "<0.001",
as.character(round(t.test_results$p.value, 3)))
# Save
output[max(which(output$vars == i)), "test"] = t.test_p
} else   {
# Run ANOVA
anova_results = summary(aov(data[, i] ~ data[, grouping.var]))
anova_p = ifelse(anova_results[[1]][["Pr(>F)"]] < 0.001, "<0.001",
as.character(round(anova_results[[1]][["Pr(>F)"]], 3)))
# Save
output[max(which(output$vars == i)), "test"] = anova_p
}
} else   {
## Run chi.square test
chisq_results = chisq.test(data[, i], data[, grouping.var], correct = TRUE)
chisq_p = ifelse(chisq_results$p.value < 0.001, "<0.001",
as.character(round(chisq_results$p.value, 3)))
# Save
output[max(which(output$vars == i)), "test"] = chisq_p
}
## Fill group column
for(g in group.levels)  {
nrow_group = nrow(data[data[, grouping.var] == g,])
if(output.type == "cat")   {
# Add proportion
for(j in 2:(length(which(output$vars == i))- 1)) {
temp_rows = which(output$vars == i)
temp_cell_no = nrow(data[data[, grouping.var] == g &
data[,i] == output[temp_rows[j], "levels"],])
output[temp_rows[j], g] =
paste0(temp_cell_no, " (",
round(temp_cell_no / nrow_group * 100, round_dec), "%)")
}
} else   {
# Mean (SD)
output[output$vars == i & output$description == paste0(placeholder, "Mean (SD)"), g] =
paste0(round(mean(data[data[,grouping.var] == g, i], na.rm = TRUE), round_dec), " (",
round(sd(data[data[,grouping.var] == g, i], na.rm = TRUE), round_dec), ")")
# Median (IQR)
output[output$vars == i & output$description == paste0(placeholder, "Median (IQR)"), g] =
paste0(round(median(data[data[,grouping.var] == g, i], na.rm = TRUE), round_dec),
" (", round(summary(data[data[,grouping.var] == g, i])[2], round_dec), "-",
round(summary(data[data[,grouping.var] == g, i])[5], round_dec), ")")
}
# Add missing
output[output$vars == i & output$description == paste0(placeholder, "Missing (%)"), g] =
paste0(sum(is.na(data[data[,grouping.var] == g, i])), " (",
round(sum(is.na(data[data[,grouping.var] == g, i])) / nrow_group * 100,
round_dec), "%)")
}
}
return(output)
}
createOutputTable <- function(
data,
vars,
labels,
round_dec,
placeholder,
var.details
)   {
## Create empty table
output = data.frame(vars = character(),
levels = character(),
output.type = character(),
description = character(),
statistic = character())
## Get nrow
nrow_data = nrow(data)
for(i in 1:length(vars))    {
## Get new row numbers
output.type = var.details[i, "output"]
newrows_start = nrow(output) + 1
newrows_end = newrows_start + ifelse(output.type == "cont", 3,
var.details[i, "levels"] + 1)
newrows = newrows_start:newrows_end
## Get unique values if categorical output.type
if(output.type == "cat")      {
output.values = unique(data[, vars[i]])
output.values = sort(output.values[!is.na(output.values)])
}
## Create new empty rows
output[newrows,] = NA
## Set vars, levels, output.type & labels
output[newrows, "vars"] = vars[i]
output[newrows, "output.type"] = output.type
output[newrows_start, "description"] = labels[i]
output[newrows_end, "description"] = paste0(placeholder, "Missing (%)")
## Write differently for continuous and categorical variables
if(output.type == "cont")     {
# Set descriptions
output[newrows[2:3], "description"] = paste0(placeholder, c("Mean (SD)",
"Median (IQR)"))
# Fill Mean (SD)
output[newrows[2], "statistic"] =
paste0(round(mean(data[,vars[i]], na.rm = TRUE), round_dec), " (",
round(sd(data[, vars[i]], na.rm = TRUE), round_dec), ")")
# Fill Median (IQR)
output[newrows[3], "statistic"] =
paste0(round(median(data[,vars[i]], na.rm = TRUE), round_dec), " (",
round(summary(data[, vars[i]])[2], round_dec), "-",
round(summary(data[, vars[i]])[5], round_dec), ")")
} else      {
# Set descriptions
output[newrows[2:(length(newrows) - 1)], "description"] =
as.character(output.values)
# Fill N (%)
for(j in output.values) {
output[output$description == j, "statistic"] =
paste0(sum(data[!is.na(data[, vars[i]]), vars[i]] == j), " (",
round(sum(data[!is.na(data[, vars[i]]), vars[i]] == j) /
nrow_data * 100, round_dec),
"%)")
}
# Save output.value as levels and add zeroes to output.value descriptions
output[newrows[2:(length(newrows) - 1)], "levels"] =
output[newrows[2:(length(newrows) - 1)], "description"]
output[newrows[2:(length(newrows) - 1)], "description"] =
paste0(placeholder, output.values)
}
## Set missing N (%)
output[newrows_end, "statistic"] =
paste0(sum(is.na(data[, vars[i]])), " (",
round(sum(is.na(data[, vars[i]])) / nrow_data * 100, round_dec), "%)")
}
## Return output
return(output)
}
# Infer classes and levels of variables
var.details = data.frame(var = vars,
class = NA,
levels = NA)
# Set labels
if(is.null(labels)){labels = vars}
for(i in vars) {
var.details[var.details$var == i, "class"] = class(data[, i])
var.details[var.details$var == i, "levels"] = length(unique(data[!is.na(data[, i]), i]))
}
# Define table class
var.details$output = ifelse(var.details$class %in% c("numeric", "integer") &
var.details$levels > 2, "cont", "cat")
## Create output table
output = createOutputTable(data = data, vars = vars, labels = labels,
var.details = var.details, round_dec = round_dec,
placeholder = placeholder)
output
output$description == paste0(placeholder, "Missing (%)") &
output$statistic == "0 (0%)"
output$description == paste0(placeholder, "Missing (%)")
# Delete missing value rows
row_to_delete = output$description == paste0(placeholder, "Missing (%)")
output[!row_to_delete,]
grouping.var = "Period"
## Extend table with grouping variables
if(!is.null(grouping.var)) {
output = addGroupInfoToTable(data = data, output = output,
vars = vars, grouping.var = grouping.var,
placeholder = placeholder,  welch.test = welch.test)
}
output
welch.test
# Set labels
if(is.null(labels)){labels = vars}
# Give error if labels have different length
if(length(labels) != length(vars))  {
stop("labels needs to be the same length as vars.")
}
# Infer classes and levels of variables
var.details = data.frame(var = vars,
class = NA,
levels = NA)
for(i in vars) {
var.details[var.details$var == i, "class"] = class(data[, i])
var.details[var.details$var == i, "levels"] = length(unique(data[!is.na(data[, i]), i]))
}
# Define table class
var.details$output = ifelse(var.details$class %in% c("numeric", "integer") &
var.details$levels > 2, "cont", "cat")
## Create output table
output = createOutputTable(data = data, vars = vars, labels = labels,
var.details = var.details, round_dec = round_dec,
placeholder = placeholder)
## Extend table with grouping variables
if(!is.null(grouping.var)) {
output = addGroupInfoToTable(data = data, output = output,
vars = vars, grouping.var = grouping.var,
placeholder = placeholder,  welch.test = welch.test)
}
head(airquality)
data = airquality
## Extend table with grouping variables
if(!is.null(grouping.var)) {
output = addGroupInfoToTable(data = data, output = output,
vars = vars, grouping.var = grouping.var,
placeholder = placeholder,  welch.test = welch.test)
}
output
output$test
c(output$test[2:length(output$test)], NA)
output$test = c(output$test[2:length(output$test)], NA)
output
# Delete missing value rows
row_to_delete = output$description == paste0(placeholder, "Missing (%)")
output = output[!row_to_delete,]
output
.libPaths("C:/Users/nkapp/R")
library("devtools")
document()
.libPaths("C:/Users/nkapp/R")
library("devtools")
document()
document()
