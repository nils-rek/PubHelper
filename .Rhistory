var.details[var.details$var == i, "levels"] = length(unique(data[!is.na(data[, i]), i]))
}
# Define table class
var.details$output = ifelse(var.details$class %in% c("numeric", "integer") &
var.details$levels > 2, "cont", "cat")
## Create output table
output = createOutputTable(data = data, vars = vars, labels = labels,
var.details = var.details, round_dec = round_dec,
placeholder = placeholder)
output
output$description == paste0(placeholder, "Missing (%)") &
output$statistic == "0 (0%)"
output$description == paste0(placeholder, "Missing (%)")
# Delete missing value rows
row_to_delete = output$description == paste0(placeholder, "Missing (%)")
output[!row_to_delete,]
grouping.var = "Period"
## Extend table with grouping variables
if(!is.null(grouping.var)) {
output = addGroupInfoToTable(data = data, output = output,
vars = vars, grouping.var = grouping.var,
placeholder = placeholder,  welch.test = welch.test)
}
output
welch.test
# Set labels
if(is.null(labels)){labels = vars}
# Give error if labels have different length
if(length(labels) != length(vars))  {
stop("labels needs to be the same length as vars.")
}
# Infer classes and levels of variables
var.details = data.frame(var = vars,
class = NA,
levels = NA)
for(i in vars) {
var.details[var.details$var == i, "class"] = class(data[, i])
var.details[var.details$var == i, "levels"] = length(unique(data[!is.na(data[, i]), i]))
}
# Define table class
var.details$output = ifelse(var.details$class %in% c("numeric", "integer") &
var.details$levels > 2, "cont", "cat")
## Create output table
output = createOutputTable(data = data, vars = vars, labels = labels,
var.details = var.details, round_dec = round_dec,
placeholder = placeholder)
## Extend table with grouping variables
if(!is.null(grouping.var)) {
output = addGroupInfoToTable(data = data, output = output,
vars = vars, grouping.var = grouping.var,
placeholder = placeholder,  welch.test = welch.test)
}
head(airquality)
data = airquality
## Extend table with grouping variables
if(!is.null(grouping.var)) {
output = addGroupInfoToTable(data = data, output = output,
vars = vars, grouping.var = grouping.var,
placeholder = placeholder,  welch.test = welch.test)
}
output
output$test
c(output$test[2:length(output$test)], NA)
output$test = c(output$test[2:length(output$test)], NA)
output
# Delete missing value rows
row_to_delete = output$description == paste0(placeholder, "Missing (%)")
output = output[!row_to_delete,]
output
.libPaths("C:/Users/nkapp/R")
library("devtools")
document()
.libPaths("C:/Users/nkapp/R")
library("devtools")
document()
document()
data(airquality)
head(airquality)
model = lm(Temp ~ Wind, data = airquality)
summary(model)
?stopifnot
stopifnot(is.null(model), "A model object must be specified.")
stopifnot(1 == 1, all.equal(pi, 3.14159265), 1 < 2)
stopifnot(1 == 2, all.equal(pi, 3.14159265), 1 < 2)
class(model)
# Get GLM class
glm_class = class(model)
summary(model)
coef(model)
names(coef(model))
coef(model)
sqrt(diag(vcov(model)))
summary(model)
summary(model)[["coefficients"]][, "t value"]
summary(model)[["coefficients"]][, "Pr(>|t|)"]
summary(model)$r.squared
rep(NA, length(coef(model)) - 1)
summary(model)$r.squared)
summary(model)$r.squared
c(rep(NA, length(coef(model)) - 1), summary(model)$r.squared)
str(summary(model))
output = data.frame(
Predictor = names(coef(model)),
Estimate = coef(model),
SE = sqrt(diag(vcov(model))),
tval = summary(model)[["coefficients"]][, "t value"],
pval = summary(model)[["coefficients"]][, "Pr(>|t|)"],
r.squared = c(rep(NA, length(coef(model)) - 1), summary(model)$r.squared),
adj.r.squared = c(rep(NA, length(coef(model)) - 1), summary(model)$adj.r.squared),
)
output = data.frame(
Predictor = names(coef(model)),
Estimate = coef(model),
SE = sqrt(diag(vcov(model))),
tval = summary(model)[["coefficients"]][, "t value"],
pval = summary(model)[["coefficients"]][, "Pr(>|t|)"],
r.squared = c(rep(NA, length(coef(model)) - 1), summary(model)$r.squared),
adj.r.squared = c(rep(NA, length(coef(model)) - 1), summary(model)$adj.r.squared)
)
output
with(output, Estimate - 1.96* SE)
format_lm = function(
model = model
) {
## Create data.frame with model output
output = data.frame(
Predictor = names(coef(model)),
Estimate = coef(model),
SE = sqrt(diag(vcov(model))),
tval = summary(model)[["coefficients"]][, "t value"],
pval = summary(model)[["coefficients"]][, "Pr(>|t|)"],
r.squared = c(rep(NA, length(coef(model)) - 1), summary(model)$r.squared),
adj.r.squared = c(rep(NA, length(coef(model)) - 1), summary(model)$adj.r.squared)
)
## Calculate 95% CI
output$ci.lb = with(output, Estimate - 1.96* SE)
output$ci.ub = with(output, Estimate - 1.96* SE)
## Return output
return(output)
}
output = data.frame(
Predictor = names(coef(model)),
Estimate = coef(model),
SE = sqrt(diag(vcov(model))),
tval = summary(model)[["coefficients"]][, "t value"],
pval = summary(model)[["coefficients"]][, "Pr(>|t|)"],
r.squared = c(rep(NA, length(coef(model)) - 1), summary(model)$r.squared),
adj.r.squared = c(rep(NA, length(coef(model)) - 1), summary(model)$adj.r.squared)
)
## Calculate 95% CI
output$ci.lb = with(output, Estimate - 1.96* SE)
output$ci.ub = with(output, Estimate - 1.96* SE)
output
output$ci.ub = with(output, Estimate + 1.96* SE)
output
round_dec = 2
round(output[, c("Estimate", "SE", "pval")], round_dec)
output$pval = ifelse(output$pval < 0.001, "<0.001",
as.character(round(output$pval, 3)))
head(output)
output[output$Predictor != "(Intercept)",]
exclude.covariates = "Wind"
output[output$Predictor %in% exclude.covariates,]
head(airquality)
model = lm(Temp ~ Wind + Ozone, data = airquality)
summary(model)
output = format_lm(model = model)
output
exclude.covariates = "Ozone"
sum(!is.na(output[output$Predictor %in% exclude.covariates, "r.squared"]))
sum(!is.na(output[output$Predictor %in% exclude.covariates, "r.squared"])) == 1
output[nrow(output), c("r.squared", "adj.r.squared")]
lm_model.fit = output[nrow(output), c("r.squared", "adj.r.squared")]
is.null(xy)
exists(lm_model.fit2)
exists("lm_model.fit")
exists("lm_model.fit2")
output
## Exclude covariate rows
output = output[output$Predictor %in% exclude.covariates == FALSE,]
output
## Include fit statistics again if necessary
if(exists("lm_model.fit"))  {output[nrow(output), c("r.squared", "adj.r.squared")] = lm_model.fit}
output
with(output, data.frame(
Predictor = Predictor,
'Estimate (SE)' = paste0(round(Estimate, round_dec), " (",
round(SE, round_dec), ")"),
'T-Value' = tval
))
## Format P-value
output$pval = ifelse(output$pval < 0.001, "<0.001",
as.character(round(output$pval, 3)))
with(output, data.frame(
Predictor = Predictor,
Estimate.SE = paste0(round(Estimate, round_dec), " (",
round(SE, round_dec), ")"),
CI = paste0(round(ci.lb, round_dec), "-", round(ci.ub, round_dec)),
T.Value = round(tval, round_dec),
P = pval,
R2 = round(r.squared, round_dec),
R2.adj = round(adj.r.squared, round_dec)
))
lm.ci = FALSE
output = with(output, data.frame(
Predictor = Predictor,
Estimate.SE = paste0(round(Estimate, round_dec), " (",
round(SE, round_dec), ")"),
CI = paste0(round(ci.lb, round_dec), "-", round(ci.ub, round_dec)),
T.Value = round(tval, round_dec),
P = pval,
R2 = round(r.squared, round_dec),
R2.adj = round(adj.r.squared, round_dec)
))
output
## Delete CI if indicated
if(lm.ci == FALSE)  {output$CI = NULL}
output
head(airquality)
?baselineTable
library("PubHelper")
.libPaths()
.libPaths("C:/Users/nkapp/R")
library("PubHelper")
?baselineTable
airquality$Period = ifelse(airquality$Month %in% 5:7, "Early Summer", "Late Summer")
model = glm(Period ~ Wind + Temp, data = airquality, family = "binomial")
airquality$earlySummer = ifelse(airquality$Month %in% 5:7, 1, 0)
model = glm(earlySummer ~ Wind + Temp, data = airquality, family = "binomial")
summary(model)
class(model)
class(model) == "lm"
identical(glm_class, "lm")
identical(class(model), c("glm", "lm"))
summary(model)
names(coef(model))
coef(model)
sqrt(diag(vcov(model)))
summary(model)
summary(model)[["coefficients"]][, "z value"]
summary(model)[["coefficients"]][, "Pr(>|t|)"]
summary(model)[["coefficients"]][, "Pr(>|z|)"]
exp(coef(model))
output = data.frame(
Predictor = names(coef(model)),
OR = exp(coef(model)),
Estimate = coef(model),
SE = sqrt(diag(vcov(model))),
zval = summary(model)[["coefficients"]][, "z value"],
pval = summary(model)[["coefficients"]][, "Pr(>|z|)"]
)
## Calculate 95% CI
output$ci.lb = exp(with(output, Estimate - 1.96* SE))
output$ci.ub = exp(with(output, Estimate + 1.96* SE))
output
## Format P-value
output$pval = ifelse(output$pval < 0.001, "<0.001",
as.character(round(output$pval, 3)))
with(output, data.frame(
Predictor = Predictor,
Estimate.SE = paste0(round(Estimate, round_dec), " (",
round(SE, round_dec), ")"),
OR.CI = paste0(round(OR, round_dec), " (",
round(ci.lb, round_dec), "-",
round(ci.lb, round_dec), ")"),
Z.Value = round(zval, round_dec),
P = pval
))
output[output$Predictor == "(Intercept)", "OR.CI"]
output = with(output, data.frame(
Predictor = Predictor,
Estimate.SE = paste0(round(Estimate, round_dec), " (",
round(SE, round_dec), ")"),
OR.CI = paste0(round(OR, round_dec), " (",
round(ci.lb, round_dec), "-",
round(ci.lb, round_dec), ")"),
Z.Value = round(zval, round_dec),
P = pval
))
output[output$Predictor == "(Intercept)", "OR.CI"]
## Set Intercept OR to "-"
output[output$Predictor == "(Intercept)", "OR.CI"] = "-"
output
output = output[output$Predictor != "(Intercept)", ]
output[output$Predictor == "(Intercept)", "OR.CI"] = "-"
output
library("devtools")
document()
.libPaths("C:/Users/nkapp/R")
.libPaths()
?write.table
library("devtools")
document()
.libPaths("C:/Users/nkapp/R")
library("devtools")
document()
.libPaths("C:/Users/nkapp/R")
library("devtools")
document()
.libPaths("C:/Users/nkapp/R")
library("devtools")
document()
data("bfi")
library("devtools")
.libPaths("C:/Users/nkapp/R")
data("bfi")
library("devtools")
data("airquality")
head(airquality)
?polr
??olr
??polr
library("MASS")
.W <- Womenlf
.W$partic <- factor(.W$partic, levels=c("not.work", "parttime", "fulltime"))
poTest(polr(partic ~ hincome + children + region, data=.W))
?poTest
?poTest()
library("devtools")
install_githubt("nkappelmann/PubHelper")
install_github("nkappelmann/PubHelper")
library("PubHelper")
head(airquality)
airquality$earlysummer = ifelse(airquality$Motn)
airquality$earlysummer = ifelse(airquality$Month %in% 4:8, 1, 0)
model = glm(earlysummer ~ Temp + Wind, data = airquality)
model = glm(earlysummer ~ Temp + Wind, data = airquality, family = "binomial")
summary(model)
formatGLMTable(model)
data(cars)
head(cars)
table(cars$speed)
table(cars$dist)
cars$speed_cat = ifelse(cars$speed > 20, 2, ifelse(cars$speed > 15, 1, 0))
head(cars)
tail(cars)
require("MASS")
polr(speed_cat ~ dist, data = cars)
polr(factor(speed_cat) ~ dist, data = cars)
model = polr(factor(speed_cat) ~ dist, data = cars)
summary(model)
confint(model)
0.09494 - 1.96*0.021
class(model)
glm_class = class(model)
identical(glm_class, "polr")
summary(model)
confint.default(model)
identical(glm_class, "polr")
0.09494 - 1.96*0.021
summary(model)
summary(model)[, "t value"]
str(model)
coef(model)
summary(model)[["coefficients"]]
names(coef(model))
exp(coef(model))
coef(model)
summary(model)[["coefficients"]]
## Get additional output
coeftable = summary(model)[["coefficients"]
output$SE = summary(model)[["coefficients"]][row.names(s)]
## Calculate 95% CI
output[, c("ci.lb", "ci.ub")] = exp(confint.default(model))
## Return output
return(output)
}
## Get additional output
coeftable = summary(model)[["coefficients"]]
coeftable
## Create data.frame with model output
output = data.frame(
Predictor = names(coef(model)),
OR = exp(coef(model)),
Estimate = coef(model)
)
output
## Get additional output
coeftable = summary(model)[["coefficients"]]
coeftable[row.names(coef.table %in% output$Predictor),]
coeftable[row.names(coeftable %in% output$Predictor),]
coeftable[row.names(coeftable) %in% output$Predictor,]
output[, c("SE", "tval")] =
coeftable[row.names(coeftable) %in% output$Predictor, c("Std. Error", "t value")]
head(output)
pnorm(abs(output$tval, lower.tail = FALSE) * 2
)
pnorm(abs(output$tval), lower.tail = FALSE) * 2
format_polr = function(
model = model
) {
## Create data.frame with model output
output = data.frame(
Predictor = names(coef(model)),
OR = exp(coef(model)),
Estimate = coef(model)
)
## Get SE, t-value, and p-value from output
coeftable = summary(model)[["coefficients"]]
output[, c("SE", "tval")] =
coeftable[row.names(coeftable) %in% output$Predictor, c("Std. Error", "t value")]
output$pval = pnorm(abs(output$tval), lower.tail = FALSE) * 2
## Calculate 95% CI
output[, c("ci.lb", "ci.ub")] = exp(confint.default(model))
## Remove coeftable
rm(coeftable)
## Return output
return(output)
}
format_polr(model)
formatGLMTable = function(
model = NULL,
intercept = TRUE,
exclude.covariates = NULL,
round_dec = 2,
lm.ci = FALSE
) {
# Get GLM class
glm_class = class(model)
# Run getGLMTable to get output data.frame
output = getGLMTable(model = model,
intercept = intercept,
exclude.covariates = exclude.covariates)
## Format P-value
output$pval = ifelse(output$pval < 0.001, "<0.001",
as.character(round(output$pval, 3)))
## Return output depending on glm_class
if(identical(glm_class, "lm")) {
output = with(output, data.frame(
Predictor = Predictor,
Estimate.SE = paste0(round(Estimate, round_dec), " (",
round(SE, round_dec), ")"),
CI = paste0(round(ci.lb, round_dec), "-", round(ci.ub, round_dec)),
T.Value = round(tval, round_dec),
P = pval,
R2 = round(r.squared, round_dec),
R2.adj = round(adj.r.squared, round_dec)
))
## Delete CI if indicated
if(lm.ci == FALSE)  {output$CI = NULL}
## Return lm output
return(output)
} else if(identical(glm_class, c("glm", "lm"))) {
output = with(output, data.frame(
Predictor = Predictor,
Estimate.SE = paste0(round(Estimate, round_dec), " (",
round(SE, round_dec), ")"),
OR.CI = paste0(round(OR, round_dec), " (",
round(ci.lb, round_dec), "-",
round(ci.ub, round_dec), ")"),
Z.Value = round(zval, round_dec),
P = pval
))
## Set Intercept OR to "-"
output[output$Predictor == "(Intercept)", "OR.CI"] = "-"
## Return lm output
return(output)
} else if(identical(glm_class, "polr")) {
output = with(output, data.frame(
Predictor = Predictor,
Estimate.SE = paste0(round(Estimate, round_dec), " (",
round(SE, round_dec), ")"),
OR.CI = paste0(round(OR, round_dec), " (",
round(ci.lb, round_dec), "-",
round(ci.ub, round_dec), ")"),
T.Value = round(tval, round_dec),
P = pval
))
## Set Intercept OR to "-"
output[output$Predictor == "(Intercept)", "OR.CI"] = "-"
## Return lm output
return(output)
}
}
formatGLMTable(model)
getGLMTable = function(
model = NULL,
intercept = TRUE,
exclude.covariates = NULL
) {
# Check if model was specified
if(is.null(model))  {stop("Model must be specified.")}
# Get GLM class
glm_class = class(model)
## Call correct formatting function depending on glm_class
if(identical(glm_class, "lm")) {output = format_lm(model = model)}
else if(identical(glm_class, c("glm", "lm"))) {output = format_loglm(model = model)}
else if(identical(glm_class, "polr")) {output = format_polr(model = model)}
else  {stop("GLMTable function not yet defined for model class.")}
## Exclude intercept if indicated
if(intercept == FALSE)  {output = output[output$Predictor != "(Intercept)",]}
## Exclude covariates if indicated
if(!is.null(exclude.covariates))  {
## Save model fit statistics, so these won't be deleted
if(identical(glm_class, "lm") &
sum(!is.na(output[output$Predictor %in% exclude.covariates, "r.squared"])) == 1) {
lm_model.fit = output[nrow(output), c("r.squared", "adj.r.squared")]
}
## Exclude covariate rows
output = output[output$Predictor %in% exclude.covariates == FALSE,]
## Include fit statistics again if necessary
if(exists("lm_model.fit"))  {
output[nrow(output), c("r.squared", "adj.r.squared")] = lm_model.fit
}
}
## Return output
return(output)
}
formatGLMTable(model)
.libPaths("C:/Users/nkapp/R")
library("devtools")
document()
