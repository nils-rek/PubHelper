if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Return output
return(output)
}
# format_loglm-----------------------
format_loglm = function(
model = model,
fit.indices = fit.indices
) {
## Extract model output
output = broom::tidy(model, conf.int = TRUE, conf.level = 0.95)
## Add OR and convert CI
output$OR = exp(output$estimate)
temp.conf.int = exp(output[, c("conf.low", "conf.high")])
output[, c("conf.low", "conf.high")] = NULL
output[, c("conf.low", "conf.high")] = temp.conf.int
rm(temp.conf.int)
## Exclude covariates
output = excludeCovariates(output = output, exclude.covariates = exclude.covariates)
## Exctract fit indices
glance.model = glance(model)
# Delete non-required fit indices
if(fit.indices == FALSE)  {
glance.model = glance.model[, "nobs"]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Return output
return(output)
}
# format_polr------------------------
format_polr = function(
model = model,
fit.indices = fit.indices,
polr.assumptioncheck = polr.assumptioncheck
) {
## Extract model output
output = broom::tidy(model, conf.int = TRUE, conf.level = 0.95)
## Delete intercepts and coef.type column
output = output[output$coef.type == "coefficient",]
output$coef.type = NULL
## Add OR and convert CI
output$OR = exp(output$estimate)
temp.conf.int = exp(output[, c("conf.low", "conf.high")])
output[, c("conf.low", "conf.high")] = NULL
output[, c("conf.low", "conf.high")] = temp.conf.int
rm(temp.conf.int)
## Exclude covariates
output = excludeCovariates(output = output, exclude.covariates = exclude.covariates)
## Exctract fit indices
glance.model = glance(model)
# Delete non-required fit indices
if(fit.indices == FALSE)  {
glance.model = glance.model[, "nobs"]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Run mlm assumption if polr.assumptioncheck = TRUE
if(polr.assumptioncheck == TRUE)  {
# Get mlm data and change colnames
mlm.dat = model$model
mlm.model = nnet::multinom(formula = deparse(formula(model)), data = model$model,
Hess = "Hessian" %in% names(model))
M1 = logLik(model)
M2 = logLik(mlm.model)
G = -2 * (M1[1] - M2[1])
output[nrow(output), "prop.test"] = pchisq(G, 3, lower.tail = FALSE)
## Remove temporary variables
rm(M1); rm(M2); rm(G)
} else  {output[nrow(output), "prop.test"] = NA}
## Return output
return(output)
}
# format_lm--------------------------
# excludeCovariates------------------
excludeCovariates = function(
output = output,
covars = exclude.covariates
)  {
output = output[!grepl(paste(covars, collapse = "|"), output$term),]
return(output)
}
GLMTables = map_df(models, getGLMTable,
intercept = FALSE, exclude.covariates = z)
#' Get a Table of GLM results
#'
#' This function creates a table including output from common GLM models. formatGLMtable offers further formatting for direct inclusion in scientific publications
#' @param model Data needs to be entered that includes relevant variables for the baseline table
#' @param intercept Should intercepts be included in the output? Default is TRUE.
#' @param exclude.covariates Specify covariates that should be excluded from the output.
#' @param fit.indices Should all fit indices from broom::glance be included? Default is FALSE.
#' @param polr.assumptioncheck Only if ordinal logistic regression is used. This calculates a multinomial model using the nnet package with the same formula as the ordinal logistic regression model. If included, a p-value for the proportionality assumption will be included in the output under column name prop.test. Note that this code only works if variables aren't converted inside the fomula (i.e., factor(Y) ~ X does not work).
#' @keywords GLM; table
#' @export
#' @author Nils Kappelmann
#' @examples
#' data(airquality)
#' model = lm(Temp ~ Wind, data = airquality)
#' getGLMTable(model = model)
getGLMTable = function(
model = NULL,
intercept = TRUE,
exclude.covariates = NULL,
fit.indices = FALSE,
polr.assumptioncheck = FALSE
) {
# Load required broom package
require("broom")
# Check if model was specified
if(is.null(model))  {stop("Model must be specified.")}
# Get GLM class
glm_class = class(model)
## Call correct formatting function depending on glm_class
if(identical(glm_class, "lm")) {output = format_lm(model = model)}
else if(identical(glm_class, c("glm", "lm"))) {output = format_loglm(model = model)}
else if(identical(glm_class, "polr")) {
output = format_polr(model = model, mlm.model = mlm.model)
} else  {stop("GLMTable function not yet defined for model class.")}
## Exclude intercept if indicated
if(intercept == FALSE)  {output = output[output$term != "(Intercept)",]}
## Return output
return(output)
}
# format_lm--------------------------
format_lm = function(
model = model,
fit.indices = fit.indices
) {
## Extract model output
output = broom::tidy(model, conf.int = TRUE, conf.level = 0.95)
## Exclude covariates
output = excludeCovariates(output = output, covars = exclude.covariates)
## Exctract fit indices
glance.model = glance(model)
# Delete non-required fit indices
if(fit.indices == FALSE)  {
glance.model = glance.model[, c("r.squared", "adj.r.squared", "nobs")]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Return output
return(output)
}
# format_loglm-----------------------
format_loglm = function(
model = model,
fit.indices = fit.indices
) {
## Extract model output
output = broom::tidy(model, conf.int = TRUE, conf.level = 0.95)
## Add OR and convert CI
output$OR = exp(output$estimate)
temp.conf.int = exp(output[, c("conf.low", "conf.high")])
output[, c("conf.low", "conf.high")] = NULL
output[, c("conf.low", "conf.high")] = temp.conf.int
rm(temp.conf.int)
## Exclude covariates
output = excludeCovariates(output = output, covars = exclude.covariates)
## Exctract fit indices
glance.model = glance(model)
# Delete non-required fit indices
if(fit.indices == FALSE)  {
glance.model = glance.model[, "nobs"]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Return output
return(output)
}
# format_polr------------------------
format_polr = function(
model = model,
fit.indices = fit.indices,
polr.assumptioncheck = polr.assumptioncheck
) {
## Extract model output
output = broom::tidy(model, conf.int = TRUE, conf.level = 0.95)
## Delete intercepts and coef.type column
output = output[output$coef.type == "coefficient",]
output$coef.type = NULL
## Add OR and convert CI
output$OR = exp(output$estimate)
temp.conf.int = exp(output[, c("conf.low", "conf.high")])
output[, c("conf.low", "conf.high")] = NULL
output[, c("conf.low", "conf.high")] = temp.conf.int
rm(temp.conf.int)
## Exclude covariates
output = excludeCovariates(output = output, covars = exclude.covariates)
## Exctract fit indices
glance.model = glance(model)
# Delete non-required fit indices
if(fit.indices == FALSE)  {
glance.model = glance.model[, "nobs"]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Run mlm assumption if polr.assumptioncheck = TRUE
if(polr.assumptioncheck == TRUE)  {
# Get mlm data and change colnames
mlm.dat = model$model
mlm.model = nnet::multinom(formula = deparse(formula(model)), data = model$model,
Hess = "Hessian" %in% names(model))
M1 = logLik(model)
M2 = logLik(mlm.model)
G = -2 * (M1[1] - M2[1])
output[nrow(output), "prop.test"] = pchisq(G, 3, lower.tail = FALSE)
## Remove temporary variables
rm(M1); rm(M2); rm(G)
} else  {output[nrow(output), "prop.test"] = NA}
## Return output
return(output)
}
# format_lm--------------------------
# excludeCovariates------------------
excludeCovariates = function(
output = output,
covars = exclude.covariates
)  {
output = output[!grepl(paste(covars, collapse = "|"), output$term),]
return(output)
}
GLMTables = map_df(models, getGLMTable,
intercept = FALSE, exclude.covariates = z)
data(airquality)
head(airquality)
y = Ozone
y = "Ozone"
x = c("Solar.R", "Wind")
z = "Temp"
.libPaths("C:/Users/nkapp/R")
#' Get a Table of GLM results
#'
#' This function creates a table including output from common GLM models. formatGLMtable offers further formatting for direct inclusion in scientific publications
#' @param model Data needs to be entered that includes relevant variables for the baseline table
#' @param intercept Should intercepts be included in the output? Default is TRUE.
#' @param exclude.covariates Specify covariates that should be excluded from the output.
#' @param fit.indices Should all fit indices from broom::glance be included? Default is FALSE.
#' @param polr.assumptioncheck Only if ordinal logistic regression is used. This calculates a multinomial model using the nnet package with the same formula as the ordinal logistic regression model. If included, a p-value for the proportionality assumption will be included in the output under column name prop.test. Note that this code only works if variables aren't converted inside the fomula (i.e., factor(Y) ~ X does not work).
#' @keywords GLM; table
#' @export
#' @author Nils Kappelmann
#' @examples
#' data(airquality)
#' model = lm(Temp ~ Wind, data = airquality)
#' getGLMTable(model = model)
getGLMTable = function(
model = NULL,
intercept = TRUE,
exclude.covariates = NULL,
fit.indices = FALSE,
polr.assumptioncheck = FALSE
) {
# Load required broom package
require("broom")
# Check if model was specified
if(is.null(model))  {stop("Model must be specified.")}
# Get GLM class
glm_class = class(model)
## Call correct formatting function depending on glm_class
if(identical(glm_class, "lm")) {output = format_lm(model = model)}
else if(identical(glm_class, c("glm", "lm"))) {output = format_loglm(model = model)}
else if(identical(glm_class, "polr")) {
output = format_polr(model = model, mlm.model = mlm.model)
} else  {stop("GLMTable function not yet defined for model class.")}
## Exclude intercept if indicated
if(intercept == FALSE)  {output = output[output$term != "(Intercept)",]}
## Return output
return(output)
}
# format_lm--------------------------
format_lm = function(
model = model,
fit.indices = fit.indices
) {
## Extract model output
output = broom::tidy(model, conf.int = TRUE, conf.level = 0.95)
## Exclude covariates
output = excludeCovariates(output = output, exclude.covariates = exclude.covariates)
## Exctract fit indices
glance.model = glance(model)
# Delete non-required fit indices
if(fit.indices == FALSE)  {
glance.model = glance.model[, c("r.squared", "adj.r.squared", "nobs")]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Return output
return(output)
}
# format_loglm-----------------------
format_loglm = function(
model = model,
fit.indices = fit.indices
) {
## Extract model output
output = broom::tidy(model, conf.int = TRUE, conf.level = 0.95)
## Add OR and convert CI
output$OR = exp(output$estimate)
temp.conf.int = exp(output[, c("conf.low", "conf.high")])
output[, c("conf.low", "conf.high")] = NULL
output[, c("conf.low", "conf.high")] = temp.conf.int
rm(temp.conf.int)
## Exclude covariates
output = excludeCovariates(output = output, exclude.covariates = exclude.covariates)
## Exctract fit indices
glance.model = glance(model)
# Delete non-required fit indices
if(fit.indices == FALSE)  {
glance.model = glance.model[, "nobs"]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Return output
return(output)
}
# format_polr------------------------
format_polr = function(
model = model,
fit.indices = fit.indices,
polr.assumptioncheck = polr.assumptioncheck
) {
## Extract model output
output = broom::tidy(model, conf.int = TRUE, conf.level = 0.95)
## Delete intercepts and coef.type column
output = output[output$coef.type == "coefficient",]
output$coef.type = NULL
## Add OR and convert CI
output$OR = exp(output$estimate)
temp.conf.int = exp(output[, c("conf.low", "conf.high")])
output[, c("conf.low", "conf.high")] = NULL
output[, c("conf.low", "conf.high")] = temp.conf.int
rm(temp.conf.int)
## Exclude covariates
output = excludeCovariates(output = output, exclude.covariates = exclude.covariates)
## Exctract fit indices
glance.model = glance(model)
# Delete non-required fit indices
if(fit.indices == FALSE)  {
glance.model = glance.model[, "nobs"]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Run mlm assumption if polr.assumptioncheck = TRUE
if(polr.assumptioncheck == TRUE)  {
# Get mlm data and change colnames
mlm.dat = model$model
mlm.model = nnet::multinom(formula = deparse(formula(model)), data = model$model,
Hess = "Hessian" %in% names(model))
M1 = logLik(model)
M2 = logLik(mlm.model)
G = -2 * (M1[1] - M2[1])
output[nrow(output), "prop.test"] = pchisq(G, 3, lower.tail = FALSE)
## Remove temporary variables
rm(M1); rm(M2); rm(G)
} else  {output[nrow(output), "prop.test"] = NA}
## Return output
return(output)
}
# format_lm--------------------------
# excludeCovariates------------------
excludeCovariates = function(
output = output,
exclude.covariates = exclude.covariates
)  {
output = output[!grepl(paste(exclude.covariates, collapse = "|"), output$term),]
return(output)
}
data = airquality
glm_fun = lm
## Add required packages
require("tidyverse")
## Check if input arguments are present
if(is.null(data))  {stop("data needs to be specified.")}
if(is.null(x))  {stop("x needs to be specified.")}
if(is.null(y))  {stop("y needs to be specified.")}
## Get grid
output = expand.grid(y = y, x = x, stringsAsFactors = FALSE)
## Get formula
output$formula = paste0(output$y, "~", output$x)
if(!is.null(z)) {
z.comb = paste(z, collapse = "+")
output$formula = paste(output$formula, z.comb, sep = "+")
}
## Run models
models = map(output$formula, glm_fun, data = data, ...)
models = map(output$formula, glm_fun, data = data)
names(models)
GLMTables = map_df(models, PubHelper::getGLMTable,
intercept = FALSE, exclude.covariates = z)
GLMTables
GLMTables = map_df(models, getGLMTable,
intercept = FALSE, exclude.covariates = z)
map_df()
?map_df
GLMTables = map_dfr(models, PubHelper::getGLMTable,
intercept = FALSE, exclude.covariates = z)
GLMTables = map_dfr(models, getGLMTable,
intercept = FALSE, exclude.covariates = z)
GLMTables
GLMTables = map_dfr(models, .f = getGLMTable(intercept = FALSE, exclude.covariates = z))
GLMTables = map_dfr(models, .f = getGLMTable(model = .,
intercept = FALSE, exclude.covariates = z))
GLMTables = map_dfr(models, .f = getGLMTable, intercept = FALSE, exclude.covariates = z)
z
exclude.covariates = z
model = models[[1]]
summary(model)
intercept = FALSE
exclude.covariates = z
fit.indices = FALSE
# Load required broom package
require("broom")
# Check if model was specified
if(is.null(model))  {stop("Model must be specified.")}
# Get GLM class
glm_class = class(model)
## Call correct formatting function depending on glm_class
if(identical(glm_class, "lm")) {output = format_lm(model = model)}
## Call correct formatting function depending on glm_class
if(identical(glm_class, "lm")) {output = format_lm(model = parent.frame()$model)}
parent.frame()$model
## Call correct formatting function depending on glm_class
if(identical(glm_class, "lm")) {output = format_lm(model)}
fun1 = function(x = 1:10) {
output = x^2
output = fun2()
return(output)
}
fun = function()  {
output = output - mean(output)
return(output)
}
fun1 = function(x = 1:10) {
output = x^2
output = fun2()
return(output)
}
fun2 = function()  {
output = output - mean(output)
return(output)
}
fun1()
fun2 = function()  {
output = output / 2
return(output)
}
fun2
fun2 = function()  {
output = output / 2
return(output)
}
fun1()
fun1 = function(x = 1:10, y = 2) {
output = x^2
output = fun2(output)
return(output)
}
fun2 = function(input)  {
output = input / y
return(output)
}
fun1()
x = 1:10
y = 2
output = x^2
output = fun2(output)
output
