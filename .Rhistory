#' data(airquality)
#' model = lm(Temp ~ Wind, data = airquality)
#' getGLMTable(model = model)
getGLMTable = function(
model = NULL,
intercept = TRUE,
exclude.covariates = NULL,
fit.indices = FALSE,
polr.assumptioncheck = FALSE
) {
# Load required broom package
require("broom")
# Check if model was specified
if(is.null(model))  {stop("Model must be specified.")}
# Get GLM class
glm_class = class(model)
## Call correct formatting function depending on glm_class
if(identical(glm_class, "lm")) {
output = format_lm(lm.object = model,
covars.to.exclude = exclude.covariates,
fit.stats = fit.indices)
} else if(identical(glm_class, c("glm", "lm"))) {
output = format_loglm(loglm.object = model,
covars.to.exclude = exclude.covariates,
fit.stats = fit.indices)
} else if(identical(glm_class, "polr")) {
output = format_polr(polr.object = model,
covars.to.exclude = exclude.covariates,
fit.stats = fit.indices)
} else  {stop("GLMTable function not yet defined for model class.")}
## Exclude intercept if indicated
if(intercept == FALSE)  {output = output[output$term != "(Intercept)",]}
## Return output
return(output)
}
# format_lm--------------------------
format_lm = function(
lm.object = model,
covars.to.exclude = exclude.covariates,
fit.stats = fit.indices
) {
## Extract model output
output = broom::tidy(lm.object, conf.int = TRUE, conf.level = 0.95)
## Exclude covariates
if(!is.null(covars.to.exclude))  {
output = excludeCovariates(output, covars.to.exclude)
}
## Exctract fit indices
glance.model = glance(lm.object)
# Delete non-required fit indices
if(fit.stats == FALSE)  {
glance.model = glance.model[, c("r.squared", "adj.r.squared", "nobs")]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Return output
return(output)
}
# format_loglm-----------------------
format_loglm = function(
loglm.object = model,
covars.to.exclude = exclude.covariates,
fit.stats = fit.indices
) {
## Extract model output
output = broom::tidy(loglm.object, conf.int = TRUE, conf.level = 0.95)
## Add OR and convert CI
output$OR = exp(output$estimate)
temp.conf.int = exp(output[, c("conf.low", "conf.high")])
output[, c("conf.low", "conf.high")] = NULL
output[, c("conf.low", "conf.high")] = temp.conf.int
rm(temp.conf.int)
## Exclude covariates
if(!is.null(covars.to.exclude))  {
output = excludeCovariates(output, covars.to.exclude)
}
## Exctract fit indices
glance.model = glance(loglm.object)
# Delete non-required fit indices
if(fit.stats == FALSE)  {
glance.model = glance.model[, "nobs"]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Return output
return(output)
}
# format_polr------------------------
format_polr = function(
polr.object = model,
covars.to.exclude = exclude.covariates,
fit.stats = fit.indices,
polr.check = polr.assumptioncheck
) {
## Extract model output
output = broom::tidy(polr.object, conf.int = TRUE, conf.level = 0.95)
## Delete intercepts and coef.type column
output = output[output$coef.type == "coefficient",]
output$coef.type = NULL
## Add OR and convert CI
output$OR = exp(output$estimate)
temp.conf.int = exp(output[, c("conf.low", "conf.high")])
output[, c("conf.low", "conf.high")] = NULL
output[, c("conf.low", "conf.high")] = temp.conf.int
rm(temp.conf.int)
## Exclude covariates
if(!is.null(covars.to.exclude))  {
output = excludeCovariates(output, covars.to.exclude)
}
## Exctract fit indices
glance.model = glance(polr.object)
# Delete non-required fit indices
if(fit.stats == FALSE)  {
glance.model = glance.model[, "nobs"]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Run mlm assumption if polr.check = TRUE
if(polr.check == TRUE)  {
# Get mlm data and change colnames
mlm.dat = polr.object$model
mlm.model = nnet::multinom(formula = deparse(formula(polr.object)),
data = polr.object$model,
Hess = "Hessian" %in% names(polr.object))
M1 = logLik(polr.object)
M2 = logLik(mlm.model)
G = -2 * (M1[1] - M2[1])
output[nrow(output), "prop.test"] = pchisq(G, 3, lower.tail = FALSE)
## Remove temporary variables
rm(M1); rm(M2); rm(G)
} else  {output[nrow(output), "prop.test"] = NA}
## Return output
return(output)
}
# format_lm--------------------------
# excludeCovariates------------------
excludeCovariates = function(
x,
exclude.from.x
)  {
x = x[!grepl(paste(exclude.from.x, collapse = "|"), x$term),]
return(x)
}
#' Loop over getGLMTable or formatGLMTable IN PROGRESS!
#'
#' This function is a wrapper that loops over getGLMTable or formatGLMTable to create a single output data frame
#' @param data Data.frame including model variables
#' @param x Vector of predictor variables
#' @param y Vector of outcome variables
#' @param z Vector of covariates if covariates are included
#' @param model.type Specify which statistical model to run. Options are "lm" for linear regression, "glm" for logistic regression, and "polr" for ordinal logistic regression
#' @param simplify Should full lm models and GLMTables be excluded from output? Default is TRUE.
#' @param ... Other arguments for GLM
#' @keywords GLM; table
#' @export
#' @author Nils Kappelmann
#' @examples
#' data(airquality)
#' model = lm(Temp ~ Wind, data = airquality)
#' getGLMTable(model = model)
loopGLMTable = function(
data = NULL,
y = NULL,
x = NULL,
z = NULL,
model.type = "lm",
simplify = TRUE
) {
## Add required packages
require("tidyverse")
## Rename data to avoid recursive errors
d = data
## Check if input arguments are present
if(is.null(d))  {stop("data needs to be specified.")}
if(is.null(x))  {stop("x needs to be specified.")}
if(is.null(y))  {stop("y needs to be specified.")}
## Get grid
output = expand.grid(y = y, x = x, stringsAsFactors = FALSE)
## Get formula
output$formula = paste0(output$y, "~", output$x)
if(!is.null(z)) {
z.comb = paste(z, collapse = "+")
output$formula = paste(output$formula, z.comb, sep = "+")
}
## Run models
if(model.type == "lm")  {
models = map(output$formula, lm, data = d)
} else if(model.type == "glm")  {
models = map(output$formula, glm, data = d, family = "binomial")
} else if(model.type == "polr") {
models = map(output$formula, MASS::polr, data = d, Hess = TRUE)
} else{stop("model.type not defined.")}
## Add results to data
GLMTables = map_dfr(models, getGLMTable,
intercept = FALSE, exclude.covariates = z)
output[,colnames(GLMTables)] = GLMTables
## Add complex model results if simplify = FALSE
if(simplify == FALSE) {
output$models = models
output$GLMTables = map(models, getGLMTable)
}
return(output)
}
data(airquality)
head(airquality)
y = "Ozone"
x = c("Solar.R", "Wind")
z = "Temp"
loopGLMTable(data = airquality, y = y, x = x, z = z)
head(airquality)
library("devtools")
devtools::document()
devtools::document()
devtools::document()
.libPaths("C:/Users/nkapp/R")
library("devtools")
install_github("nkappelmann/PubHelper")
library("PubHelper")
data(airquality)
head(airquality)
?mapGLMTables
getGLMTable = function(
model = NULL,
intercept = TRUE,
exclude.covariates = NULL,
fit.indices = FALSE,
polr.assumptioncheck = FALSE
) {
# Load required broom package
require("broom")
# Check if model was specified
if(is.null(model))  {stop("Model must be specified.")}
# Get GLM class
glm_class = class(model)
## Call correct formatting function depending on glm_class
if(identical(glm_class, "lm")) {
output = format_lm(lm.object = model,
covars.to.exclude = exclude.covariates,
fit.stats = fit.indices)
} else if(identical(glm_class, c("glm", "lm"))) {
output = format_loglm(loglm.object = model,
covars.to.exclude = exclude.covariates,
fit.stats = fit.indices)
} else if(identical(glm_class, "polr")) {
output = format_polr(polr.object = model,
covars.to.exclude = exclude.covariates,
fit.stats = fit.indices)
} else  {stop("GLMTable function not yet defined for model class.")}
## Exclude intercept if indicated
if(intercept == FALSE)  {output = output[output$term != "(Intercept)",]}
## Return output
return(output)
}
# format_lm--------------------------
format_lm = function(
lm.object = model,
covars.to.exclude = exclude.covariates,
fit.stats = fit.indices
) {
## Extract model output
output = broom::tidy(lm.object, conf.int = TRUE, conf.level = 0.95)
## Exclude covariates
if(!is.null(covars.to.exclude))  {
output = excludeCovariates(output, covars.to.exclude)
}
## Exctract fit indices
glance.model = glance(lm.object)
# Delete non-required fit indices
if(fit.stats == FALSE)  {
glance.model = glance.model[, c("r.squared", "adj.r.squared", "nobs")]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Return output
return(output)
}
# format_loglm-----------------------
format_loglm = function(
loglm.object = model,
covars.to.exclude = exclude.covariates,
fit.stats = fit.indices
) {
## Extract model output
output = broom::tidy(loglm.object, conf.int = TRUE, conf.level = 0.95)
## Add OR and convert CI
output$OR = exp(output$estimate)
temp.conf.int = exp(output[, c("conf.low", "conf.high")])
output[, c("conf.low", "conf.high")] = NULL
output[, c("conf.low", "conf.high")] = temp.conf.int
rm(temp.conf.int)
## Exclude covariates
if(!is.null(covars.to.exclude))  {
output = excludeCovariates(output, covars.to.exclude)
}
## Exctract fit indices
glance.model = glance(loglm.object)
# Delete non-required fit indices
if(fit.stats == FALSE)  {
glance.model = glance.model[, "nobs"]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Return output
return(output)
}
# format_polr------------------------
format_polr = function(
polr.object = model,
covars.to.exclude = exclude.covariates,
fit.stats = fit.indices,
polr.check = polr.assumptioncheck
) {
## Extract model output
output = broom::tidy(polr.object, conf.int = TRUE, conf.level = 0.95)
## Delete intercepts and coef.type column
output = output[output$coef.type == "coefficient",]
output$coef.type = NULL
## Add OR and convert CI
output$OR = exp(output$estimate)
temp.conf.int = exp(output[, c("conf.low", "conf.high")])
output[, c("conf.low", "conf.high")] = NULL
output[, c("conf.low", "conf.high")] = temp.conf.int
rm(temp.conf.int)
## Exclude covariates
if(!is.null(covars.to.exclude))  {
output = excludeCovariates(output, covars.to.exclude)
}
## Exctract fit indices
glance.model = glance(polr.object)
# Delete non-required fit indices
if(fit.stats == FALSE)  {
glance.model = glance.model[, "nobs"]
}
# Add fit indices to output
if(nrow(output) > 1)  {
for(i in 1:(nrow(output) - 1))  {
glance.model = rbind(rep(NA, ncol(glance.model)), glance.model)
}
}
output[, colnames(glance.model)] = glance.model
## Run mlm assumption if polr.check = TRUE
if(polr.check == TRUE)  {
# Get mlm data and change colnames
mlm.dat = polr.object$model
mlm.model = nnet::multinom(formula = deparse(formula(polr.object)),
data = polr.object$model,
Hess = "Hessian" %in% names(polr.object))
M1 = logLik(polr.object)
M2 = logLik(mlm.model)
G = -2 * (M1[1] - M2[1])
output[nrow(output), "prop.test"] = pchisq(G, 3, lower.tail = FALSE)
## Remove temporary variables
rm(M1); rm(M2); rm(G)
} else  {output[nrow(output), "prop.test"] = NA}
## Return output
return(output)
}
# format_lm--------------------------
# excludeCovariates------------------
excludeCovariates = function(
x,
exclude.from.x
)  {
x = x[!grepl(paste(exclude.from.x, collapse = "|"), x$term),]
return(x)
}
loopGLMTable = function(
data = NULL,
y = NULL,
x = NULL,
z = NULL,
model.type = "lm",
simplify = TRUE
) {
## Add required packages
require("tidyverse")
## Rename data to avoid recursive errors
d = data
## Check if input arguments are present
if(is.null(d))  {stop("data needs to be specified.")}
if(is.null(x))  {stop("x needs to be specified.")}
if(is.null(y))  {stop("y needs to be specified.")}
## Get grid
output = expand.grid(y = y, x = x, stringsAsFactors = FALSE)
## Get formula
output$formula = paste0(output$y, "~", output$x)
if(!is.null(z)) {
z.comb = paste(z, collapse = "+")
output$formula = paste(output$formula, z.comb, sep = "+")
}
## Run models
if(model.type == "lm")  {
models = map(output$formula, lm, data = d)
} else if(model.type == "glm")  {
models = map(output$formula, glm, data = d, family = "binomial")
} else if(model.type == "polr") {
models = map(output$formula, MASS::polr, data = d, Hess = TRUE)
} else{stop("model.type not defined.")}
## Add results to data
GLMTables = map_dfr(models, getGLMTable,
intercept = FALSE, exclude.covariates = z)
output[,colnames(GLMTables)] = GLMTables
## Add complex model results if simplify = FALSE
if(simplify == FALSE) {
output$models = models
output$GLMTables = map(models, getGLMTable)
}
return(output)
}
data(airquality)
head(airquality)
model = lm(Ozone~Solar.R)
model = lm(Ozone~Solar.R, data = airquality)
summary(model)
getGLMTable(model)
head(airquality)
mapGLMTables(data = airquality, y = "Ozone", x = c("Solar.R", "Wind"), z = c("Temp", "Month"))
mapGLMTables = function(
data = NULL,
y = NULL,
x = NULL,
z = NULL,
model.type = "lm",
simplify = TRUE
) {
## Add required packages
require("tidyverse")
## Rename data to avoid recursive errors
d = data
## Check if input arguments are present
if(is.null(d))  {stop("data needs to be specified.")}
if(is.null(x))  {stop("x needs to be specified.")}
if(is.null(y))  {stop("y needs to be specified.")}
## Get grid
output = expand.grid(y = y, x = x, stringsAsFactors = FALSE)
## Get formula
output$formula = paste0(output$y, "~", output$x)
if(!is.null(z)) {
z.comb = paste(z, collapse = "+")
output$formula = paste(output$formula, z.comb, sep = "+")
}
## Run models
if(model.type == "lm")  {
models = map(output$formula, lm, data = d)
} else if(model.type == "glm")  {
models = map(output$formula, glm, data = d, family = "binomial")
} else if(model.type == "polr") {
models = map(output$formula, MASS::polr, data = d, Hess = TRUE)
} else{stop("model.type not defined.")}
## Add results to data
GLMTables = map_dfr(models, getGLMTable,
intercept = FALSE, exclude.covariates = z)
output[,colnames(GLMTables)] = GLMTables
## Add complex model results if simplify = FALSE
if(simplify == FALSE) {
output$models = models
output$GLMTables = map(models, getGLMTable)
}
return(output)
}
mapGLMTables(data = airquality, y = "Ozone", x = c("Solar.R", "Wind"), z = c("Temp", "Month"))
complex = mapGLMTables(data = airquality, y = "Ozone", x = c("Solar.R", "Wind"), z = "Temp", simplify = FALSE)
str(complex)
View(complex)
complex$GLMTables[[1]]
mapGLMTables(data = airquality, y = "Ozone", x = c("Solar.R", "Wind"), z = "Temp", simplify = TRUE, model.type = "lm")
mapGLMTables(data = airquality, y = "Ozone", x = c("Solar.R", "Wind"), z = "Temp", simplify = TRUE, model.type = "glm")
airquality$lateSummer = ifelse(airquality$Month > 7, 1, 0)
mapGLMTables(data = airquality, y = "lateSummer", x = c("Solar.R", "Wind"), z = "Temp", simplify = TRUE, model.type = "glm")
library("devtools")
.libPaths("C:/Users/nkapp/R")
library("devtools")
devtools::document()
.libPaths("C:/Users/nkapp/R")
library("devtools")
install_github("nkappelmann/PubHelper")
library("PubHelper")
?mapGLMTables
data(airquality)
mapGLMTables(data = airquality, y = "Ozone", x = c("Solar.R", "Wind"), z = "Temp")
.libPaths("C:/Users/nkapp/R")
library("PubHelper")
?mapGLMTables
library("devtools")
.libPaths("C:/Users/nkapp/R")
library("devtools")
devtools::document()
